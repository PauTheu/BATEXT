%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Appendix %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Appendix}
\label{ch:appendix}


\section{Berechnung der Distanzen nach \textcite{kitahara2017technology}}
\label{appendix:omega}


\vphantom{dasddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd}

\begin{lstlisting}[style=python]

# Berechnet die Distanz zweier Firmen nach Kitahara und Oikawa (2017)
def omega(z0,z1,eta=0.5):
    
    '''
    z0, z1 - Zitate von Firma_0 und Firma_1 als dictionary,
    eta - technologischer Diskontierungsfaktor,
    zitate2 - Zitate der zweiten Ebene als dictionary - gibt an welches Patent zitiert,
    zitate2R - Rückrichtung der Zitate auf der zweiten Ebene als dictionary - gibt an von welchem Patente zitiert wird
    '''
    
    '''
    In diesem Teil des Codes wird nur der Omegatyp und die Gewichtung der Patente bestimmt, Mehrfachzitate werden bei der Berechnung der Omegawerte
    im zweiten Teil des Codes berücksichtigt
    '''
    
    # omega^1, Schnittmenge, erste Zitierebene
    ov = set(z0) & set(z1) 
    
    # Übrige Patente (~P_ij und ~P_ji)
    A0 = set(z0) - ov
    A1 = set(z1) - ov
    
    # Gewichtung der omega^1
    g = dict()
    for p in ov:
        g[p] = (1,0)
        
    # omega^21 und omega^22 in Richtung 01 (ij), Gewichtung    
    for p in A0:
        gewicht = 0
        typ = 0
        if p in zitate2:
            a = zitate2[p] - ov # Einschränkung der Menge auf noch nicht berechnete Zitate (~P'_ij,)
            schnitt = a & A1 
            if len(schnitt) > 0:    # omega^21-typ
                gewicht = len(schnitt)/len(a)
                typ = 1
            else:                   # evtl omega^22-typ
                for q in a:
                    if q in zitate2R: 
                        qv = zitate2R[q]
                        schnitt = qv & A1
                        gewicht += len(schnitt)/len(a)
                        typ = 2

            if gewicht > 0:
                g[p] = (gewicht,typ)
    
    # omega^21 und omega^22 in Richtung 10 (ji), Gewichtung 
    for p in A1:
        gewicht = 0
        typ = 0
        if p in zitate2:
            a = zitate2[p] - ov
            schnitt = a & A0
            if len(schnitt) > 0:    # omega^21-typ
                gewicht = len(schnitt)/len(a)
                typ = 3
            else:                   # evtl omega^22-typ
                for q in a:
                    if q in zitate2R: 
                        qv = zitate2R[q]
                        schnitt = qv & A0
                        gewicht += len(schnitt)/len(a)
                        typ = 4

            if gewicht > 0:
                g[p] = (gewicht,typ)
         
        
    '''
    In zweiten Teil des Codes berechnen wir die verschiedenen Omegawerte anhand ihrer Gewichtung
    '''
        
        
    om01_1 = sum([g[k][0]*v for (k,v) in z0.items() if k in g and g[k][1] == 0])
    om01_1 += sum([g[k][0]*v for (k,v) in z1.items() if k in g and g[k][1] == 0])    
    om01_21 = sum([g[k][0]*v for (k,v) in z0.items() if k in g and g[k][1] == 1])
    om01_22 = sum([g[k][0]*v for (k,v) in z0.items() if k in g and g[k][1] == 2])
    om10_21 = sum([g[k][0]*v for (k,v) in z1.items() if k in g and g[k][1] == 3])
    om10_22 = sum([g[k][0]*v for (k,v) in z1.items() if k in g and g[k][1] == 4])
    
    # Berechnung des finalen Omegawertes
    om = om01_1 + eta * (om01_21 + om10_21) + eta * eta * (om01_22 + om10_22)
    nenner = sum(x for x in z0.values()) + sum(x for x in z1.values())
  
    # Berechnung der Distanz d_ij
    return  -np.log(om/nenner)
    
    
\end{lstlisting}

\vphantom{dasddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd}